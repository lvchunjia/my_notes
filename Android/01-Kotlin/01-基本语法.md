

> [Kotlin 官方文档 中文版](https://book.kotlincn.net/)



# 一、语法基础

## 1. 程序入口点

Kotlin 应用程序的入口点是 `main` 函数。

```kotlin
fun main() {
    println("Hello world!")
}
```

`main` 的另一种形式接受可变数量的 `String` 参数。

```kotlin
fun main(args: Array<String>) {
    println(args.contentToString())
}
```

## 2. 输出打到标准输出

`print` 将其参数打到标准输出。

```kotlin
fun main() {
//sampleStart
    print("Hello ")
    print("world!")
//sampleEnd
}
```

`println` 输出其参数并添加换行符，以便接下来输出的内容出现在下一行。

```kotlin
fun main() {
//sampleStart
    println("Hello world!")
    println(42)
//sampleEnd
}
```

## 3. 变量

定义只读局部变量使用关键字 `val` 定义。只能为其赋值一次。

```kotlin
fun main() {
//sampleStart
    val a: Int = 1  // 立即赋值
    val b = 2   // 自动推断出 `Int` 类型
    val c: Int  // 如果没有初始值类型不能省略
    c = 3       // 明确赋值
//sampleEnd
    println("a = $a, b = $b, c = $c")
}
```

可重新赋值的变量使用 `var` 关键字。

```kotlin
fun main() {
//sampleStart
    var x = 5 // 自动推断出 `Int` 类型
    x += 1
//sampleEnd
    println("x = $x")
}
```

可以在顶层声明变量。

```kotlin
//sampleStart
val PI = 3.14
var x = 0

fun incrementX() { 
    x += 1 
}
//sampleEnd

fun main() {
    println("x = $x; PI = $PI")
    incrementX()
    println("incrementX()")
    println("x = $x; PI = $PI")
}
```

## 4. 注释

与大多数现代语言一样，Kotlin 支持单行（或*行末*）与多行（*块*）注释。

```kotlin
// 这是一个行注释

/* 这是一个多行的
   块注释。 */
```

Kotlin 中的块注释可以嵌套。

```kotlin
/* 注释从这里开始
/* 包含嵌套的注释 *&#8288;/     
并且在这里结束。 */
```



# 二、数据类型

在 Kotlin 中，所有东西都是对象，在这个意义上讲可以在任何变量上调用成员函数与属性。 一些类型可以有特殊的内部表示——例如，数字、字符以及布尔可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。

## 1. 数字

### 1.1. 整数类型

Kotlin 提供了一组表示数字的内置类型。 对于整数，有四种不同大小的类型，因此值的范围也不同：

| 类型    | 大小（比特数） | 最小值                            | 最大值                              |
| ------- | -------------- | --------------------------------- | ----------------------------------- |
| `Byte`  | 8              | -128                              | 127                                 |
| `Short` | 16             | -32768                            | 32767                               |
| `Int`   | 32             | -2,147,483,648 (-231)             | 2,147,483,647 (231 - 1)             |
| `Long`  | 64             | -9,223,372,036,854,775,808 (-263) | 9,223,372,036,854,775,807 (263 - 1) |

当初始化一个没有显式指定类型的变量时，编译器会自动推断为自 `Int` 起足以表示该值的最小类型。 如果不超过 `Int` 的表示范围，那么类型是 `Int`。 如果超过了，那么类型是 `Long`。 如需显式指定 `Long` 值，请给该值追加后缀 `L`。 显式指定类型会触发编译器检测该值是否超出指定类型的表示范围。

```kotlin
val one = 1 // Int
val threeBillion = 3000000000 // Long
val oneLong = 1L // Long
val oneByte: Byte = 1
```

> 除了整数类型之外，Kotlin 还提供无符号整数类型。[无符号整数类型](#无符号整型)

### 1.2. 浮点类型

对于实数，Kotlin 提供了浮点类型 `Float` 与 `Double` 类型，遵循 [IEEE 754 标准](https://zh.wikipedia.org/wiki/IEEE_754)。 `Float` 表达 IEEE 754 *单精度*，而 `Double` 表达*双精度*。

这两个类型的大小不同，并为两种不同精度的浮点数提供存储：

| 类型     | 大小（比特数） | 有效数字比特数 | 指数比特数 | 十进制位数 |
| -------- | -------------- | -------------- | ---------- | ---------- |
| `Float`  | 32             | 24             | 8          | 6-7        |
| `Double` | 64             | 53             | 11         | 15-16      |

可以使用带小数部分的数字初始化 `Double` 与 `Float` 变量。 小数部分与整数部分之间用句点（`.`）分隔

对于以小数初始化的变量，编译器会推断为 `Double` 类型：

```kotlin
val pi = 3.14 // Double
// val one: Double = 1 // 错误：类型不匹配
val oneDouble = 1.0 // Double
```

如需将一个值显式指定为 `Float` 类型，请添加 `f` 或 `F` 后缀。 如果这样的值包含多于 6～7 位十进制数，那么会将其舍入：

```kotlin
val e = 2.7182818284 // Double
val eFloat = 2.7182818284f // Float，实际值为 2.7182817
```

与一些其他语言不同，Kotlin 中的数字没有隐式拓宽转换。 例如，具有 `Double` 参数的函数只能对 `Double` 值调用，而不能对 `Float`、 `Int` 或者其他数字值调用：

```kotlin
fun main() {
    fun printDouble(d: Double) { print(d) }

    val i = 1    
    val d = 1.0
    val f = 1.0f 

    printDouble(d)
//    printDouble(i) // 错误：类型不匹配
//    printDouble(f) // 错误：类型不匹配
}
```

### 1.3. 数字字面常量

数值常量字面值有以下几种:

- 十进制：`123`
  - Long 类型用大写 `L` 标记: `123L`
- 十六进制: `0x0F`
- 二进制: `0b00001011`

> Kotlin 不支持八进制。

Kotlin 同样支持浮点数的常规表示方法:

- 默认 double：`123.5`、`123.5e10`
- Float 用 `f` 或者 `F` 标记: `123.5f`

可以使用下划线使数字常量更易读：

```kotlin
val oneMillion = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val socialSecurityNumber = 999_99_9999L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
```

### 1.4. JVM 平台的数字表示

在 JVM 平台数字存储为原生类型 `int`、 `double` 等。 例外情况是当创建可空数字引用如 `Int?` 或者使用泛型时。 在这些场景中，数字会装箱为 Java 类 `Integer`、 `Double` 等。

对相同数字的可为空引用可能会引用不同的对象：

```kotlin
fun main() {
//sampleStart
    val a: Int = 100
    val boxedA: Int? = a
    val anotherBoxedA: Int? = a

    val b: Int = 10000
    val boxedB: Int? = b
    val anotherBoxedB: Int? = b

    println(boxedA === anotherBoxedA) // true
    println(boxedB === anotherBoxedB) // false
//sampleEnd
}
```

由于 JVM 对 `-128` 到 `127` 的整数（`Integer`）应用了内存优化，因此，`a` 的所有可空引用实际上都是同一对象。但是没有对 `b` 应用内存优化，所以它们是不同对象。

另一方面，它们仍然相等:

```kotlin
fun main() {
//sampleStart
    val b: Int = 10000
    println(b == b) // 输出“true”
    val boxedB: Int? = b
    val anotherBoxedB: Int? = b
    println(boxedB == anotherBoxedB) // 输出“true”
//sampleEnd
}
```





### 1.3. <a name="显式数字转换">显式数字转换</a>

由于不同的表示方式，较小类型并*不是*较大类型的子类型。 如果它们是的话，就会出现下述问题：

```kotlin
// 假想的代码，实际上并不能编译：
val a: Int? = 1 // 一个装箱的 Int (java.lang.Integer)
val b: Long? = a // 隐式转换产生一个装箱的 Long (java.lang.Long)
print(b == a) // 惊！这将输出“false”鉴于 Long 的 equals() 会检测另一个是否也为 Long
```

所以会悄无声息地失去相等性，更别说同一性了。

因此较小的类型***不能** 隐式转换*为较大的类型。 这意味着把 `Byte` 型值赋给一个 `Int` 变量必须显式转换：

```kotlin
fun main() {
//sampleStart
    val b: Byte = 1 // OK, 字面值会静态检测
    // val i: Int = b // 错误
    val i1: Int = b.toInt()
//sampleEnd
}
```

所有数字类型都支持转换为其他类型：

- `toByte(): Byte`
- `toShort(): Short`
- `toInt(): Int`
- `toLong(): Long`
- `toFloat(): Float`
- `toDouble(): Double`

很多情况都不需要显式类型转换，因为类型会从上下文推断出来， 而算术运算会有重载做适当转换，例如：

```kotlin
val l = 1L + 3 // Long + Int => Long
```

### 1.4. 数字运算

Kotlin支持数字运算的标准集：`+`、 `-`、 `*`、 `/`、 `%`。它们已定义为相应的类成员：

```kotlin
fun main() {
//sampleStart
    println(1 + 2)
    println(2_500_000_000L - 1L)
    println(3.14 * 2.71)
    println(10.0 / 3)
//sampleEnd
}
```

还可以为自定义类覆盖这些操作符。详情请参见[操作符重载](https://book.kotlincn.net/text/operator-overloading.html)。

### 1.5. 整数除法

整数间的除法总是返回整数。会丢弃任何小数部分。

```kotlin
fun main() {
//sampleStart
    val x = 5 / 2
    //println(x == 2.5) // ERROR: Operator '==' cannot be applied to 'Int' and 'Double'
    println(x == 2)
//sampleEnd
}
```

对于任何两个整数类型之间的除法来说都是如此：

```kotlin
fun main() {
//sampleStart
    val x = 5L / 2
    println(x == 2L)
//sampleEnd
}
```

如需返回浮点类型，请将其中的一个参数显式转换为浮点类型：

```kotlin
fun main() {
//sampleStart
    val x = 5 / 2.toDouble()
    println(x == 2.5)
//sampleEnd
}
```

### 位运算

Kotlin 对整数提供了一组*位运算*。它们直接使用数字的比特表示在二进制级别进行操作。 位运算有可以通过中缀形式调用的函数表示。只能应用于 `Int` 与 `Long`：

```kotlin
val x = (1 shl 2) and 0x000FF000
```

这是完整的位运算列表：

- `shl(bits)` – 有符号左移
- `shr(bits)` – 有符号右移
- `ushr(bits)` – 无符号右移
- `and(bits)` – 位**与**
- `or(bits)` – 位**或**
- `xor(bits)` – 位**异或**
- `inv()` – 位非

### 浮点数比较

本节讨论的浮点数操作如下：

- 相等性检测：`a == b` 与 `a != b`
- 比较操作符：`a < b`、 `a > b`、 `a <= b`、 `a >= b`
- 区间实例以及区间检测：`a..b`、 `x in a..b`、 `x !in a..b`

当其中的操作数 `a` 与 `b` 都是静态已知的 `Float` 或 `Double` 或者它们对应的可空类型（声明为该类型，或者推断为该类型，或者[智能类型转换](https://book.kotlincn.net/text/typecasts.html#智能转换)的结果是该类型），两数字所形成的操作或者区间遵循 [IEEE 754 浮点运算标准](https://zh.wikipedia.org/wiki/IEEE_754)。

然而，为了支持泛型场景并提供全序支持，对于**并非**静态类型就是浮点数的情况，行为是不同的。例如是 `Any`、 `Comparable<...>` 或者 `Collection<T>` 类型。 这种情况下，这些操作使用为 `Float` 与 `Double` 实现的 `equals` 与 `compareTo`。 因此：

- 认为 `NaN` 与其自身相等
- 认为 `NaN` 比包括正无穷大（`POSITIVE_INFINITY`）在内的任何其他元素都大
- 认为 `-0.0` 小于 `0.0`

以下示例显示了静态类型作为浮点数 （`Double.NaN`）的操作数与静态类型**并非**作为浮点数的操作数（`listOf(T)`）之间的行为差异。

```kotlin
fun main() {
    //sampleStart
    // 静态类型作为浮点数的操作数
    println(Double.NaN == Double.NaN)                 // false
    // 静态类型并非作为浮点数的操作数
    // 所以 NaN 等于它本身
    println(listOf(Double.NaN) == listOf(Double.NaN)) // true

    // 静态类型作为浮点数的操作数
    println(0.0 == -0.0)                              // true
    // 静态类型并非作为浮点数的操作数
    // 所以 -0.0 小于 0.0
    println(listOf(0.0) == listOf(-0.0))              // false

    println(listOf(Double.NaN, Double.POSITIVE_INFINITY, 0.0, -0.0).sorted())
    // [-0.0, 0.0, Infinity, NaN]
    //sampleEnd
}
```













## <a name="无符号整型">无符号整型</a>

除了[整数类型](https://book.kotlincn.net/text/numbers.html#整数类型)，对于无符号整数，Kotlin 还提供了以下类型：

- `UByte`: 无符号 8 比特整数，范围是 0 到 255
- `UShort`: 无符号 16 比特整数，范围是 0 到 65535
- `UInt`: 无符号 32 比特整数，范围是 0 到 2^32 - 1
- `ULong`: 无符号 64 比特整数，范围是 0 到 2^64 - 1

无符号类型支持其对应有符号类型的大多数操作。

> 无符号数实现为具有单个存储属性的[内联类](https://book.kotlincn.net/text/inline-classes.html)， 该属性类型为与其宽度相同的对应有符号类型。 尽管如此，将类型从无符号类型更改为对应的有符号类型（反之亦然） 是*二进制不兼容*变更。
>
> <svg width="24" height="24" fill="#4dbb5f" viewBox="0 0 24 24"><path d="M21 12a9 9 0 1 1-9-9 9 9 0 0 1 9 9zM10.5 7.5A1.5 1.5 0 1 0 12 6a1.5 1.5 0 0 0-1.5 1.5zm-.5 3.54v1h1V18h2v-6a.96.96 0 0 0-.96-.96z"></path></svg>

## 无符号数组与区间

> 无符号数组及其对应操作处于 [Beta](https://book.kotlincn.net/text/components-stability.html) 状态。 它们可能随时进行不兼容变更。 需要选择加入（详见下文）。
>
> <svg width="24" height="24" fill="#f45b4a" viewBox="0 0 24 24"><path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path></svg>

与原生类型相同，每个无符号类型都有表示相应类型数组的类型：

- `UByteArray`: 无符号字节数组
- `UShortArray`: 无符号短整型数组
- `UIntArray`: 无符号整型数组
- `ULongArray`: 无符号长整型数组

与有符号整型数组一样，它们提供了类似于 `Array` 类的 API 而没有装箱开销。

When you use unsigned arrays, you'll get a warning that indicates that this feature is not stable yet. To remove the warning, opt-in the `@ExperimentalUnsignedTypes` annotation. It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but keep in mind that unsigned arrays are not a stable feature, so API which uses them can be broken by changes in the language. [Learn more about opt-in requirements](https://book.kotlincn.net/text/opt-in-requirements.html).

[区间与数列](https://book.kotlincn.net/text/ranges.html)也支持 `UInt` 与 `ULong`（通过这些类 `UIntRange`、 `UIntProgression`、 `ULongRange`、 `ULongProgression`）。 Together with the unsigned integer types, these classes are stable.

## 无符号整数字面值

为使无符号整型更易于使用，Kotlin 提供了用后缀标记整型字面值来表示指定无符号类型（类似于 `Float` 或 `Long`）：

- `u` and `U` tag is for unsigned literals. The exact type is determined based on the expected type. If no expected type is provided, compiler will use `UInt` or `ULong` depending on the size of literal:

  ```kotlin
  val b: UByte = 1u  // UByte，已提供预期类型
  val s: UShort = 1u // UShort，已提供预期类型
  val l: ULong = 1u  // ULong，已提供预期类型
  
  val a1 = 42u // UInt：未提供预期类型，常量适于 UInt
  val a2 = 0xFFFF_FFFF_FFFFu // ULong：未提供预期类型，常量不适于 UInt
  ```

- `uL` 与 `UL` 显式将字面值标记为无符号长整型：

  ```kotlin
  val a = 1UL // ULong，即使未提供预期类型并且常量适于 UInt
  ```



# 二、控制流程











# 三、包与导入





























